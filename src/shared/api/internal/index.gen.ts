// YouTogether API 1.0.0
// ---
// This file is automatically generated by openapi with preset openapi-preset-effector
// Do not edit this file directly. Instead open openapi config file and follow the link in "file"
import * as typed from "typed-contracts";
import { createEffect } from "effector";

import { requestFx } from "@/shared/api/request";

//#region prebuilt code
const custom = { any: (valueName: string, value: unknown): any => value };

export type GenericErrors =
  | {
      status: "unexpected";
      error: Error;
    }
  | {
      status: "unknown_status";
      error: { status: number; body: unknown };
    }
  | {
      status: "validation_error";
      error: typed.ValidationError;
    };

type ErrorCodes = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 500 | 501 | 502 | 503 | 503 | 505;
/**
 * @throws
 */
function parseByStatus<
  Variants extends string,
  Contracts extends Record<number, [Variants, typed.Contract<any>]>,
  Result extends {
    [Code in keyof Contracts]: Contracts[Code] extends [infer Status, typed.Contract<infer T>]
      ? { status: Status; answer: T }
      : never;
  },
>(
  name: string,
  response: { status: number; body?: unknown },
  contracts: Contracts,
): Result[Exclude<keyof Result, ErrorCodes>] {
  const contractObject = contracts[response.status];
  if (!contractObject) {
    throw {
      status: "unknown_status",
      error: {
        status: response.status,
        body: response.body,
      },
    };
  }
  const [status, contract] = contractObject;
  const answer = contract(name, response.body);
  if (answer instanceof typed.ValidationError) {
    throw { status: "validation_error", error: answer };
  }
  if (response.status >= 400) {
    throw { status, error: answer };
  }
  return { status, answer } as Result[Exclude<keyof Result, ErrorCodes>];
}

//#endregion prebuilt code/* --- */
//#region authSessionGet
export type AuthSessionGet = {};
/* OK */
export const authSessionGetOk = typed.object({
  name: typed.string,
  firstName: typed.string.optional,
  lastName: typed.string.optional,
  role: typed.union("USER", "ADMIN"),
  biography: typed.string.optional,
  email: typed.string,
  language: typed.union("EN", "RU"),
  theme: typed.union("DARK", "LIGHT", "SYSTEM"),
  isEmailVerified: typed.boolean,
  friendsIds: typed.array(typed.number).optional,
});
export type AuthSessionGetDone = {
  status: "ok";
  answer: typed.Get<typeof authSessionGetOk>;
};
/* User is not logged in */
export const authSessionGetUnauthorized = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* Internal Server Error */
export const authSessionGetInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type AuthSessionGetFail =
  | {
      status: "unauthorized";
      error: typed.Get<typeof authSessionGetUnauthorized>;
    }
  | {
      status: "internal_server_error";
      error: typed.Get<typeof authSessionGetInternalServerError>;
    }
  | GenericErrors;
/* Returns user session data from cookie session */
export const authSessionGet = createEffect<AuthSessionGet, AuthSessionGetDone, AuthSessionGetFail>({
  async handler() {
    const name = "authSessionGet.body";
    const response = await requestFx({
      path: "/auth/session",
      method: "GET",
    });
    return parseByStatus(name, response, {
      200: ["ok", authSessionGetOk],
      401: ["unauthorized", authSessionGetUnauthorized],
      500: ["internal_server_error", authSessionGetInternalServerError],
    });
  },
});
//#endregion authSessionGet

/* --- */
//#region authSessionDelete
export type AuthSessionDelete = {};
/* OK */
export const authSessionDeleteOk = typed.nul;
export type AuthSessionDeleteDone = {
  status: "ok";
  answer: typed.Get<typeof authSessionDeleteOk>;
};
/* Internal Server Error */
export const authSessionDeleteInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type AuthSessionDeleteFail =
  | {
      status: "internal_server_error";
      error: typed.Get<typeof authSessionDeleteInternalServerError>;
    }
  | GenericErrors;
/* Deletes user session and clear user session cookie */
export const authSessionDelete = createEffect<
  AuthSessionDelete,
  AuthSessionDeleteDone,
  AuthSessionDeleteFail
>({
  async handler() {
    const name = "authSessionDelete.body";
    const response = await requestFx({
      path: "/auth/session",
      method: "DELETE",
    });
    return parseByStatus(name, response, {
      200: ["ok", authSessionDeleteOk],
      500: ["internal_server_error", authSessionDeleteInternalServerError],
    });
  },
});
//#endregion authSessionDelete

/* --- */
//#region authEmailPost
export type AuthEmailPost = {
  body: {
    email: string;
    code: string;
  };
  header?: {
    "Accept-Language"?: "EN" | "RU";
  };
};
/* OK */
export const authEmailPostOk = typed.nul;
export type AuthEmailPostDone = {
  status: "ok";
  answer: typed.Get<typeof authEmailPostOk>;
};
/* Invalid data */
export const authEmailPostBadRequest = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* Internal Server Error */
export const authEmailPostInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type AuthEmailPostFail =
  | {
      status: "bad_request";
      error: typed.Get<typeof authEmailPostBadRequest>;
    }
  | {
      status: "internal_server_error";
      error: typed.Get<typeof authEmailPostInternalServerError>;
    }
  | GenericErrors;
/* Authorize user with code that previously was sent to email. If user with specified email does not exist, create new user. Can be used for sign-in and sign-up. */
export const authEmailPost = createEffect<AuthEmailPost, AuthEmailPostDone, AuthEmailPostFail>({
  async handler({ body, header }) {
    const name = "authEmailPost.body";
    const response = await requestFx({
      path: "/auth/email",
      method: "POST",
      body,
      header,
    });
    return parseByStatus(name, response, {
      200: ["ok", authEmailPostOk],
      400: ["bad_request", authEmailPostBadRequest],
      500: ["internal_server_error", authEmailPostInternalServerError],
    });
  },
});
//#endregion authEmailPost

/* --- */
//#region authPasswordPost
export type AuthPasswordPost = {
  body: {
    email: string;
    password: string;
  };
  header?: {
    "Accept-Language"?: "EN" | "RU";
  };
};
/* OK */
export const authPasswordPostOk = typed.nul;
export type AuthPasswordPostDone = {
  status: "ok";
  answer: typed.Get<typeof authPasswordPostOk>;
};
/* Invalid data */
export const authPasswordPostBadRequest = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* Internal Server Error */
export const authPasswordPostInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type AuthPasswordPostFail =
  | {
      status: "bad_request";
      error: typed.Get<typeof authPasswordPostBadRequest>;
    }
  | {
      status: "internal_server_error";
      error: typed.Get<typeof authPasswordPostInternalServerError>;
    }
  | GenericErrors;
/* Authorize user with email and password. If user with specified email does not exist, create new user. Can be used for sign-in and sign-up. */
export const authPasswordPost = createEffect<
  AuthPasswordPost,
  AuthPasswordPostDone,
  AuthPasswordPostFail
>({
  async handler({ body, header }) {
    const name = "authPasswordPost.body";
    const response = await requestFx({
      path: "/auth/password",
      method: "POST",
      body,
      header,
    });
    return parseByStatus(name, response, {
      200: ["ok", authPasswordPostOk],
      400: ["bad_request", authPasswordPostBadRequest],
      500: ["internal_server_error", authPasswordPostInternalServerError],
    });
  },
});
//#endregion authPasswordPost

/* --- */
//#region emailSendCodePost
export type EmailSendCodePost = {
  body: {
    email: string;
  };
};
/* OK */
export const emailSendCodePostOk = typed.nul;
export type EmailSendCodePostDone = {
  status: "ok";
  answer: typed.Get<typeof emailSendCodePostOk>;
};
/* Invalid data */
export const emailSendCodePostBadRequest = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* Internal Server Error */
export const emailSendCodePostInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type EmailSendCodePostFail =
  | {
      status: "bad_request";
      error: typed.Get<typeof emailSendCodePostBadRequest>;
    }
  | {
      status: "internal_server_error";
      error: typed.Get<typeof emailSendCodePostInternalServerError>;
    }
  | GenericErrors;
/* Generates 5-digit string, saves it and sends it to specified email */
export const emailSendCodePost = createEffect<
  EmailSendCodePost,
  EmailSendCodePostDone,
  EmailSendCodePostFail
>({
  async handler({ body }) {
    const name = "emailSendCodePost.body";
    const response = await requestFx({
      path: "/email/send-code",
      method: "POST",
      body,
    });
    return parseByStatus(name, response, {
      200: ["ok", emailSendCodePostOk],
      400: ["bad_request", emailSendCodePostBadRequest],
      500: ["internal_server_error", emailSendCodePostInternalServerError],
    });
  },
});
//#endregion emailSendCodePost

/* --- */
//#region userUsernameGet
export type UserUsernameGet = {
  path: {
    username: string;
  };
};
/* OK */
export const userUsernameGetOk = typed.object({
  name: typed.string,
  firstName: typed.string.optional,
  lastName: typed.string.optional,
  role: typed.union("USER", "ADMIN"),
  biography: typed.string.optional,
  friendsIds: typed.array(typed.number).optional,
});
export type UserUsernameGetDone = {
  status: "ok";
  answer: typed.Get<typeof userUsernameGetOk>;
};
/* Invalid data */
export const userUsernameGetBadRequest = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* Internal Server Error */
export const userUsernameGetInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type UserUsernameGetFail =
  | {
      status: "bad_request";
      error: typed.Get<typeof userUsernameGetBadRequest>;
    }
  | {
      status: "internal_server_error";
      error: typed.Get<typeof userUsernameGetInternalServerError>;
    }
  | GenericErrors;
/* Returns user's main data by username, if exist */
export const userUsernameGet = createEffect<
  UserUsernameGet,
  UserUsernameGetDone,
  UserUsernameGetFail
>({
  async handler({ path }) {
    const name = "userUsernameGet.body";
    const response = await requestFx({
      path: `/user/${path.username}`,
      method: "GET",
    });
    return parseByStatus(name, response, {
      200: ["ok", userUsernameGetOk],
      400: ["bad_request", userUsernameGetBadRequest],
      500: ["internal_server_error", userUsernameGetInternalServerError],
    });
  },
});
//#endregion userUsernameGet

/* --- */
//#region userCheckNameNameGet
export type UserCheckNameNameGet = {
  path: {
    name: string;
  };
};
/* This name isn't in use */
export const userCheckNameNameGetOk = typed.nul;
export type UserCheckNameNameGetDone = {
  status: "ok";
  answer: typed.Get<typeof userCheckNameNameGetOk>;
};
/* This name already in use */
export const userCheckNameNameGetForbidden = typed.nul;
/* Internal Server Error */
export const userCheckNameNameGetInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type UserCheckNameNameGetFail =
  | {
      status: "forbidden";
      error: typed.Get<typeof userCheckNameNameGetForbidden>;
    }
  | {
      status: "internal_server_error";
      error: typed.Get<typeof userCheckNameNameGetInternalServerError>;
    }
  | GenericErrors;
/* Checks specified name on already exist */
export const userCheckNameNameGet = createEffect<
  UserCheckNameNameGet,
  UserCheckNameNameGetDone,
  UserCheckNameNameGetFail
>({
  async handler({ path }) {
    const name = "userCheckNameNameGet.body";
    const response = await requestFx({
      path: `/user/check-name/${path.name}`,
      method: "GET",
    });
    return parseByStatus(name, response, {
      200: ["ok", userCheckNameNameGetOk],
      403: ["forbidden", userCheckNameNameGetForbidden],
      500: ["internal_server_error", userCheckNameNameGetInternalServerError],
    });
  },
});
//#endregion userCheckNameNameGet

/* --- */
//#region userPatch
export type UserPatch = {
  body: {
    firstName?: string;
    lastName?: string;
    biography?: string;
    language?: "EN" | "RU";
    theme?: "DARK" | "LIGHT" | "SYSTEM";
  };
};
/* OK */
export const userPatchOk = typed.nul;
export type UserPatchDone = {
  status: "ok";
  answer: typed.Get<typeof userPatchOk>;
};
/* Invalid data */
export const userPatchBadRequest = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* User is not logged in */
export const userPatchUnauthorized = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* Internal Server Error */
export const userPatchInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type UserPatchFail =
  | {
      status: "bad_request";
      error: typed.Get<typeof userPatchBadRequest>;
    }
  | {
      status: "unauthorized";
      error: typed.Get<typeof userPatchUnauthorized>;
    }
  | {
      status: "internal_server_error";
      error: typed.Get<typeof userPatchInternalServerError>;
    }
  | GenericErrors;
/* Updates some user's main data */
export const userPatch = createEffect<UserPatch, UserPatchDone, UserPatchFail>({
  async handler({ body }) {
    const name = "userPatch.body";
    const response = await requestFx({
      path: "/user",
      method: "PATCH",
      body,
    });
    return parseByStatus(name, response, {
      200: ["ok", userPatchOk],
      400: ["bad_request", userPatchBadRequest],
      401: ["unauthorized", userPatchUnauthorized],
      500: ["internal_server_error", userPatchInternalServerError],
    });
  },
});
//#endregion userPatch

/* --- */
//#region userPasswordPatch
export type UserPasswordPatch = {
  body: {
    email: string;
    code: string;
    newPassword: string;
  };
};
/* OK */
export const userPasswordPatchOk = typed.nul;
export type UserPasswordPatchDone = {
  status: "ok";
  answer: typed.Get<typeof userPasswordPatchOk>;
};
/* Invalid data */
export const userPasswordPatchBadRequest = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* User is not logged in */
export const userPasswordPatchUnauthorized = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* Internal Server Error */
export const userPasswordPatchInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type UserPasswordPatchFail =
  | {
      status: "bad_request";
      error: typed.Get<typeof userPasswordPatchBadRequest>;
    }
  | {
      status: "unauthorized";
      error: typed.Get<typeof userPasswordPatchUnauthorized>;
    }
  | {
      status: "internal_server_error";
      error: typed.Get<typeof userPasswordPatchInternalServerError>;
    }
  | GenericErrors;
/* Updates user's password by email */
export const userPasswordPatch = createEffect<
  UserPasswordPatch,
  UserPasswordPatchDone,
  UserPasswordPatchFail
>({
  async handler({ body }) {
    const name = "userPasswordPatch.body";
    const response = await requestFx({
      path: "/user/password",
      method: "PATCH",
      body,
    });
    return parseByStatus(name, response, {
      200: ["ok", userPasswordPatchOk],
      400: ["bad_request", userPasswordPatchBadRequest],
      401: ["unauthorized", userPasswordPatchUnauthorized],
      500: ["internal_server_error", userPasswordPatchInternalServerError],
    });
  },
});
//#endregion userPasswordPatch

/* --- */
//#region userEmailPatch
export type UserEmailPatch = {
  body: {
    newEmail: string;
    password: string;
  };
};
/* OK */
export const userEmailPatchOk = typed.nul;
export type UserEmailPatchDone = {
  status: "ok";
  answer: typed.Get<typeof userEmailPatchOk>;
};
/* Invalid data */
export const userEmailPatchBadRequest = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* User is not logged in */
export const userEmailPatchUnauthorized = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* Internal Server Error */
export const userEmailPatchInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type UserEmailPatchFail =
  | {
      status: "bad_request";
      error: typed.Get<typeof userEmailPatchBadRequest>;
    }
  | {
      status: "unauthorized";
      error: typed.Get<typeof userEmailPatchUnauthorized>;
    }
  | {
      status: "internal_server_error";
      error: typed.Get<typeof userEmailPatchInternalServerError>;
    }
  | GenericErrors;
/* Updates user's email by password */
export const userEmailPatch = createEffect<UserEmailPatch, UserEmailPatchDone, UserEmailPatchFail>({
  async handler({ body }) {
    const name = "userEmailPatch.body";
    const response = await requestFx({
      path: "/user/email",
      method: "PATCH",
      body,
    });
    return parseByStatus(name, response, {
      200: ["ok", userEmailPatchOk],
      400: ["bad_request", userEmailPatchBadRequest],
      401: ["unauthorized", userEmailPatchUnauthorized],
      500: ["internal_server_error", userEmailPatchInternalServerError],
    });
  },
});
//#endregion userEmailPatch

/* --- */
//#region userNamePatch
export type UserNamePatch = {
  body: {
    name: string;
  };
};
/* OK */
export const userNamePatchOk = typed.nul;
export type UserNamePatchDone = {
  status: "ok";
  answer: typed.Get<typeof userNamePatchOk>;
};
/* Invalid data */
export const userNamePatchBadRequest = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* User is not logged in */
export const userNamePatchUnauthorized = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
/* Internal Server Error */
export const userNamePatchInternalServerError = typed.object({
  code: typed.union("validation", "authorization", "server", "not_found"),
  description: typed.string.optional,
  advice: typed.string.optional,
  fields: typed.object({}).optional,
});
export type UserNamePatchFail =
  | {
      status: "bad_request";
      error: typed.Get<typeof userNamePatchBadRequest>;
    }
  | {
      status: "unauthorized";
      error: typed.Get<typeof userNamePatchUnauthorized>;
    }
  | {
      status: "internal_server_error";
      error: typed.Get<typeof userNamePatchInternalServerError>;
    }
  | GenericErrors;
/* Updates user name */
export const userNamePatch = createEffect<UserNamePatch, UserNamePatchDone, UserNamePatchFail>({
  async handler({ body }) {
    const name = "userNamePatch.body";
    const response = await requestFx({
      path: "/user/name",
      method: "PATCH",
      body,
    });
    return parseByStatus(name, response, {
      200: ["ok", userNamePatchOk],
      400: ["bad_request", userNamePatchBadRequest],
      401: ["unauthorized", userNamePatchUnauthorized],
      500: ["internal_server_error", userNamePatchInternalServerError],
    });
  },
});
//#endregion userNamePatch
